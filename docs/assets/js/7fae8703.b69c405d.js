(self.webpackChunketlnetdocumentation=self.webpackChunketlnetdocumentation||[]).push([[1034],{1504:function(e,n,t){"use strict";var r=t(67294),a=t(21140),s=t.n(a);s().initialize({startOnLoad:!0});n.Z=function(e){var n=e.chart;return(0,r.useEffect)((function(){s().contentLoaded()}),[]),r.createElement("pre",{className:"prism-code language-csharp codeBlock_node_modules-@docusaurus-theme-classic-lib-next-theme-CodeBlock-styles-module thin-scrollbar",style:{backgroundColor:"rgb(248, 248, 242)",color:"rgb(40, 42, 54)"}},r.createElement("div",{className:"mermaid"},n))}},72849:function(e,n,t){"use strict";t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return c},metadata:function(){return p},toc:function(){return d}});var r=t(87462),a=t(63366),s=(t(67294),t(3905)),o=t(1504),i=["components"],c={sidebar_position:7},l="Handle traces",p={unversionedId:"recipes/handleTraces",id:"recipes/handleTraces",title:"Handle traces",description:"Behind the scenes every operator reports in detail its activity to the runtime. Then the runtime broadcast all the activity reporting to a trace stream.",source:"@site/docs/recipes/7_handleTraces.mdx",sourceDirName:"recipes",slug:"/recipes/handleTraces",permalink:"/Etl.Net/docs/recipes/handleTraces",editUrl:"https://github.com/paillave/Etl.Net/blob/develop/documentation/docs/recipes/7_handleTraces.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Data access with entity framework",permalink:"/Etl.Net/docs/recipes/ef"},next:{title:"Make a console application",permalink:"/Etl.Net/docs/recipes/consoleApplication"}},u={},d=[],m={toc:d};function h(e){var n=e.components,t=(0,a.Z)(e,i);return(0,s.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"handle-traces"},"Handle traces"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"/docs/quickstart/principle"},"Behind the scenes")," every operator reports in detail its activity to the runtime. Then the runtime broadcast all the activity reporting to a trace stream."),(0,s.kt)("p",null,"The activity that is reported to the runtime to be issued into into the trace stream are the following"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The end of the stream by giving the number of events that went thought it"),(0,s.kt)("li",{parentName:"ul"},"If applicable, the exception that occurred in the operator"),(0,s.kt)("li",{parentName:"ul"},"If ",(0,s.kt)("inlineCode",{parentName:"li"},"UseDetailedTraces")," has been flagged, the actual payload/output of the operator is transmitted as well.")),(0,s.kt)("p",null,"The process to apply to this trace stream can be given to the runtime when triggering the execution of the main process."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs",metastring:"{4}","{4}":!0},'var processRunner = StreamProcessRunner.Create<string>(DefineProcess);\nvar executionOptions = new ExecutionOptions<string> \n{ \n    TraceProcessDefinition = (ts, cs) => ts.Do("Show trace on console", t => Console.WriteLine(t.ToString())) \n};\nvar res = await processRunner.ExecuteAsync(args[0], executionOptions);\n')),(0,s.kt)("p",null,"Actually the trace process definition should be defined in a dedicated function:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs",metastring:"{13}","{13}":!0},"using System.Threading.Tasks;\nusing Paillave.Etl.Core;\n\nnamespace Tutorial\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var processRunner = StreamProcessRunner.Create<string>(DefineProcess);\n            var executionOptions = new ExecutionOptions<string>\n            {\n                TraceProcessDefinition = DefineTraceProcess\n            };\n            var res = await processRunner.ExecuteAsync(args[0], executionOptions);\n        }\n        private static void DefineTraceProcess(IStream<TraceEvent> traceStream, ISingleStream<string> contentStream)\n        {\n            // TODO: define how to process traces here\n        }\n        private static void DefineProcess(ISingleStream<string> contextStream)\n        {\n            // TODO: define the process here\n        }\n    }\n}\n")),(0,s.kt)("p",null,"The stream to handle traces emits ",(0,s.kt)("inlineCode",{parentName:"p"},"TraceEvent")," payloads."),(0,s.kt)(o.Z,{chart:"\nclassDiagram\nclass TraceEvent {\n    SequenceId:int\n    ExecutionId:Guid\n    JobName:string\n    DateTime:DateTime\n    NodeName:string\n    NodeTypeName:string\n}\nclass ITraceContent {\n    <<interface>>\n    Type:string\n    Message:string\n}\nclass TraceLevel {\n    <<enumeration>>\n    Off\n    Error\n    Warning\n    Info\n    Verbose\n}\nclass StreamTraceContentBase {\n    <<abstract>>\n}\nclass CounterSummaryStreamTraceContent {\n    Level => TraceLevel.Info;\n    Counter:int\n}\nclass RowProcessStreamTraceContent {\n    Level => TraceLevel.Verbose;\n    Position:int\n    AverageDuration:int?\n    Row:object\n}\nclass UnhandledExceptionStreamTraceContent {\n    Level => TraceLevel.Error;\n    Exception:Exception\n}\nTraceEvent--\x3eITraceContent:Content\nITraceContent--\x3eTraceLevel:Level\nStreamTraceContentBase--|>ITraceContent\nCounterSummaryStreamTraceContent--|>StreamTraceContentBase\nRowProcessStreamTraceContent--|>StreamTraceContentBase\nUnhandledExceptionStreamTraceContent--|>StreamTraceContentBase",mdxType:"Mermaid"}),(0,s.kt)("p",null,"To be able to receive events with a content of type ",(0,s.kt)("inlineCode",{parentName:"p"},"RowProcessStreamTraceContent"),", the flag ",(0,s.kt)("inlineCode",{parentName:"p"},"UseDetailedTraces")," must be set as for performance purposes, it is not emitted by default:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs",metastring:"{5}","{5}":!0},'var processRunner = StreamProcessRunner.Create<string>(DefineProcess);\nvar executionOptions = new ExecutionOptions<string> \n{ \n    TraceProcessDefinition = (ts, cs) => ts.Do("Show trace on console", t => Console.WriteLine(t.ToString())),\n    UseDetailedTraces = true\n};\nvar res = await processRunner.ExecuteAsync(args[0], executionOptions);\n')),(0,s.kt)("p",null,"It is possible to do whatever is possible in a trace process, even saving things in a database. As it can happen that the target database for logging is not the same than the working database. This can be the same for anything else that is injected: if the dependency injection context needs to be different than the one for the main process, it needs to be mentioned in ",(0,s.kt)("inlineCode",{parentName:"p"},"TraceResolver"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cs",metastring:"{10}","{10}":!0},'var processRunner = StreamProcessRunner.Create<string>(DefineProcess);\nusing (var cnx = new SqlConnection(args[1]))\nusing (var tracesCnx = new SqlConnection(args[2]))\n{\n    cnx.Open();\n    var executionOptions = new ExecutionOptions<string>\n    {\n        TraceProcessDefinition = DefineTraceProcess\n        Resolver = new SimpleDependencyResolver().Register(cnx),\n        TraceResolver = new SimpleDependencyResolver().Register(tracesCnx),\n    };\n    var res = await processRunner.ExecuteAsync(args[0], executionOptions);\n    Console.Write(res.Failed ? "Failed" : "Succeeded");\n}\n')),(0,s.kt)("p",null,"A concrete example of trace process is described in the ",(0,s.kt)("a",{parentName:"p",href:"/docs/tutorials/trackAndCheck#catch-main-events-to-save-them-in-a-log-file"},"related tutorial"),"."))}h.isMDXComponent=!0},21493:function(e,n,t){var r={"./locale":89234,"./locale.js":89234};function a(e){var n=s(e);return t(n)}function s(e){if(!t.o(r,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}a.keys=function(){return Object.keys(r)},a.resolve=s,e.exports=a,a.id=21493}}]);