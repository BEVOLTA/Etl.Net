"use strict";(self.webpackChunketlnetdocumentation=self.webpackChunketlnetdocumentation||[]).push([[1034],{1504:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(7294),r=n(7273);r.Z.initialize({startOnLoad:!0});const s=e=>{let{chart:t}=e;return(0,a.useEffect)((()=>{r.Z.contentLoaded()}),[]),a.createElement("pre",{className:"prism-code language-csharp codeBlock_node_modules-@docusaurus-theme-classic-lib-next-theme-CodeBlock-styles-module thin-scrollbar",style:{backgroundColor:"rgb(248, 248, 242)",color:"rgb(40, 42, 54)"}},a.createElement("div",{className:"mermaid"},t))}},2849:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var a=n(7462),r=(n(7294),n(3905)),s=n(1504);const i={sidebar_position:7},o="Handle traces",c={unversionedId:"recipes/handleTraces",id:"recipes/handleTraces",title:"Handle traces",description:"Behind the scenes every operator reports in detail its activity to the runtime. Then the runtime broadcast all the activity reporting to a trace stream.",source:"@site/docs/recipes/7_handleTraces.mdx",sourceDirName:"recipes",slug:"/recipes/handleTraces",permalink:"/Etl.Net/docs/recipes/handleTraces",draft:!1,editUrl:"https://github.com/paillave/Etl.Net/blob/develop/documentation/docs/recipes/7_handleTraces.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Data access with entity framework",permalink:"/Etl.Net/docs/recipes/ef"},next:{title:"Make a console application",permalink:"/Etl.Net/docs/recipes/consoleApplication"}},l={},p=[],d={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"handle-traces"},"Handle traces"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/docs/quickstart/principle"},"Behind the scenes")," every operator reports in detail its activity to the runtime. Then the runtime broadcast all the activity reporting to a trace stream."),(0,r.kt)("p",null,"The activity that is reported to the runtime to be issued into into the trace stream are the following"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The end of the stream by giving the number of events that went thought it"),(0,r.kt)("li",{parentName:"ul"},"If applicable, the exception that occurred in the operator"),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"UseDetailedTraces")," has been flagged, the actual payload/output of the operator is transmitted as well.")),(0,r.kt)("p",null,"The process to apply to this trace stream can be given to the runtime when triggering the execution of the main process."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:"{4}","{4}":!0},'var processRunner = StreamProcessRunner.Create<string>(DefineProcess);\nvar executionOptions = new ExecutionOptions<string> \n{ \n    TraceProcessDefinition = (ts, cs) => ts.Do("Show trace on console", t => Console.WriteLine(t.ToString())) \n};\nvar res = await processRunner.ExecuteAsync(args[0], executionOptions);\n')),(0,r.kt)("p",null,"Actually the trace process definition should be defined in a dedicated function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:"{13}","{13}":!0},"using System.Threading.Tasks;\nusing Paillave.Etl.Core;\n\nnamespace Tutorial\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var processRunner = StreamProcessRunner.Create<string>(DefineProcess);\n            var executionOptions = new ExecutionOptions<string>\n            {\n                TraceProcessDefinition = DefineTraceProcess\n            };\n            var res = await processRunner.ExecuteAsync(args[0], executionOptions);\n        }\n        private static void DefineTraceProcess(IStream<TraceEvent> traceStream, ISingleStream<string> contentStream)\n        {\n            // TODO: define how to process traces here\n        }\n        private static void DefineProcess(ISingleStream<string> contextStream)\n        {\n            // TODO: define the process here\n        }\n    }\n}\n")),(0,r.kt)("p",null,"The stream to handle traces emits ",(0,r.kt)("inlineCode",{parentName:"p"},"TraceEvent")," payloads."),(0,r.kt)(s.Z,{chart:"\nclassDiagram\nclass TraceEvent {\n    SequenceId:int\n    ExecutionId:Guid\n    JobName:string\n    DateTime:DateTime\n    NodeName:string\n    NodeTypeName:string\n}\nclass ITraceContent {\n    <<interface>>\n    Type:string\n    Message:string\n}\nclass TraceLevel {\n    <<enumeration>>\n    Off\n    Error\n    Warning\n    Info\n    Verbose\n}\nclass StreamTraceContentBase {\n    <<abstract>>\n}\nclass CounterSummaryStreamTraceContent {\n    Level => TraceLevel.Info;\n    Counter:int\n}\nclass RowProcessStreamTraceContent {\n    Level => TraceLevel.Verbose;\n    Position:int\n    AverageDuration:int?\n    Row:object\n}\nclass UnhandledExceptionStreamTraceContent {\n    Level => TraceLevel.Error;\n    Exception:Exception\n}\nTraceEvent--\x3eITraceContent:Content\nITraceContent--\x3eTraceLevel:Level\nStreamTraceContentBase--|>ITraceContent\nCounterSummaryStreamTraceContent--|>StreamTraceContentBase\nRowProcessStreamTraceContent--|>StreamTraceContentBase\nUnhandledExceptionStreamTraceContent--|>StreamTraceContentBase",mdxType:"Mermaid"}),(0,r.kt)("p",null,"To be able to receive events with a content of type ",(0,r.kt)("inlineCode",{parentName:"p"},"RowProcessStreamTraceContent"),", the flag ",(0,r.kt)("inlineCode",{parentName:"p"},"UseDetailedTraces")," must be set as for performance purposes, it is not emitted by default:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:"{5}","{5}":!0},'var processRunner = StreamProcessRunner.Create<string>(DefineProcess);\nvar executionOptions = new ExecutionOptions<string> \n{ \n    TraceProcessDefinition = (ts, cs) => ts.Do("Show trace on console", t => Console.WriteLine(t.ToString())),\n    UseDetailedTraces = true\n};\nvar res = await processRunner.ExecuteAsync(args[0], executionOptions);\n')),(0,r.kt)("p",null,"It is possible to do whatever is possible in a trace process, even saving things in a database. As it can happen that the target database for logging is not the same than the working database. This can be the same for anything else that is injected: if the dependency injection context needs to be different than the one for the main process, it needs to be mentioned in ",(0,r.kt)("inlineCode",{parentName:"p"},"TraceResolver"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cs",metastring:"{10}","{10}":!0},'var processRunner = StreamProcessRunner.Create<string>(DefineProcess);\nusing (var cnx = new SqlConnection(args[1]))\nusing (var tracesCnx = new SqlConnection(args[2]))\n{\n    cnx.Open();\n    var executionOptions = new ExecutionOptions<string>\n    {\n        TraceProcessDefinition = DefineTraceProcess\n        Resolver = new SimpleDependencyResolver().Register(cnx),\n        TraceResolver = new SimpleDependencyResolver().Register(tracesCnx),\n    };\n    var res = await processRunner.ExecuteAsync(args[0], executionOptions);\n    Console.Write(res.Failed ? "Failed" : "Succeeded");\n}\n')),(0,r.kt)("p",null,"A concrete example of trace process is described in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/tutorials/trackAndCheck#catch-main-events-to-save-them-in-a-log-file"},"related tutorial"),"."))}u.isMDXComponent=!0}}]);